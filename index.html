<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <title>不如</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="不如">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="不如">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不如">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="不如" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/pp.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">刘思亮</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Heipiao" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
								<a class="linkedin" target="_blank" href="/#" title="linkedin">linkedin</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ML/" style="font-size: 16.67px;">ML</a> <a href="/tags/data/" style="font-size: 10px;">data</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/scikit/" style="font-size: 13.33px;">scikit</a> <a href="/tags/scikit-learn/" style="font-size: 10px;">scikit-learn</a> <a href="/tags/xgboost/" style="font-size: 10px;">xgboost</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">开始写程序~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">刘思亮</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/pp.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">刘思亮</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Heipiao" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
						<a class="linkedin" target="_blank" href="/#" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-scikit-cookbook-中文翻译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/24/scikit-cookbook-中文翻译/" class="article-date">
  	<time datetime="2015-12-24T15:56:58.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/scikit-cookbook-中文翻译/">scikit cookbook 中文翻译</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章：预处理流程">第一章：预处理流程</h1><h2 id="简介">简介</h2><p>这一章讨论了数据准备和预建模维度约简。这些不是机器学习最有吸引力的部分，但是它们决定了模型是否成功。<br>这里有三个主要的部分，首先，我们创造了假的数据。这个看起来很琐碎，但是创造假的数据是一个重要的步骤在模型测试。在我们使用算法时十分实用的，为了完整性，我们创造了数据。第二，我们广泛的转化数据作为处理的过程包括了明确的变量编码。第三，我们讨论了大量特征被观察的情景。<br>这一章，尤其前半章为之后的章节搭建的舞台。为了使用scikit-learn数据时必须的。前两个小节我们讨论获取数据，后一半章节我们讨论处理数据。</p>
<h2 id="获取外部的数据">获取外部的数据</h2><p>如果可能，尽量在这本书内使用相同的数据集。这时内置的数据集被用来检验不同的模型技法例如<strong>回归</strong>和<strong>分类</strong>。这里在大多数情况下，对于有名的数据集，已经有了各个领域的很多论文，用来拟合模型和比较其他模型。</p>
<h2 id="做好准备">做好准备</h2><p>这里我们使用datasets模块，使用以下的命令：</p>
<pre><code><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
</code></pre><h2 id="如何去做">如何去做</h2><p>这里主要有两种数据模型，小型的数据集，已datasets.load_的形式，和缺省的形式代表较大的数据集。<em>更多情况，最好测试模型与算法使用与现实情况相符合的复杂度</em>。<br>首先载入boston数据集，并测试：</p>
<pre><code>boston = datasets.<span class="function"><span class="title">load_boston</span><span class="params">()</span></span>
print boston<span class="class">.DESCR</span> <span class="id">#output</span> omitted due to length
</code></pre><p>接下来，fetch一个数据集：</p>
<pre><code>housing = datasets.<span class="function"><span class="title">fetch_california_housing</span><span class="params">()</span></span>
downloading Cal. housing from http:<span class="comment">//lib.stat.cmu.edu [...]</span>
print housing<span class="class">.DESCR</span> <span class="id">#output</span> omitted due to length
</code></pre><h2 id="怎样工作">怎样工作</h2><p>当数据集被载入的时候，它并不是以NumPy数组的形式。它的类型是Bunch。这时一种python普通的数据结构。他是一个基本的字典和键值，作为类的属性。<br>为了使用数据的属性。Numpy的数组包含不独立的变量，目标属性是独立的变量。</p>
<pre><code>X, y = boston.<span class="type">data</span>, boston.<span class="type">target</span>
</code></pre><p>这里有Bunch对象的可能的实现，自己实现也不复杂， scikit-learn在base模块定义。我们可以参见：<a href="https://github.com/scikit-learn/scikit-learn/blob/" target="_blank" rel="external"> https://github.com/scikit-learn/scikit-learn/blob/</a></p>
<h2 id="更多的事">更多的事</h2><p> UCI Machine Learning Repository是一个实例数据集，更多的数据集在scikit_learn，这里有很多可以使用的数据。另外的实现是KDD，本地政府和kaggle竞赛。</p>
<h1 id="创建实例数据作为分析">创建实例数据作为分析</h1><p>在这一节我们使用scikit创造一些数据作为测试。</p>
<h2 id="开始准备">开始准备</h2><p>与内置数据十分相似，获取新数据和创造实例数据。这个函数约定命名 make_<the data="" set="">，这个数据是纯粹手工的。<br>为了储存类型，import数据集作为d：<br>     import sklearn.datasets as d<br>     import numpy as np</the></p>
<h2 id="怎样去做">怎样去做</h2><p>这一节我们将创造几个数据集，这节将证实所谓的数据特征，另外对于样例数据集，我们将展示必须的特征使用一些算法。<br>首先stalwart 回归：<br>     reg_data = d.make_regression()<br>默认情况下，这里会产生100x100的矩阵，100个样例的100个特征。然而，只有10个特征是必须的目标数据产生，第二个元祖成员的目标变量。这里我们，举个例子为了生成1000x10的矩阵和五个特征，偏执值是1.0和2个目标，应该执行下面的命令：<br>    complex_reg_data = d.make_regression(1000, 10, 5, 2, 1.0)</p>
<p>分类的数据集创建也十分简单。这里十分简单去创建基础的分类集，但是基础的情况很少在实践中使用大多数使用者不会转化，大多数的转化是假的。所以，在不平衡数据集中探索分类是很有用的。</p>
<pre><code>classification_set = d.<span class="function"><span class="title">make_classification</span><span class="params">(weights=[<span class="number">0.1</span>])</span></span>
np.<span class="function"><span class="title">bincount</span><span class="params">(classification_set[<span class="number">1</span>])</span></span>
</code></pre><p>聚类也将被创建，这里有几个算法，创建数据集。例如blobs函数十分容易创建使用K-Means模型：</p>
<pre><code>blobs = d.<span class="function"><span class="title">make_blobs</span><span class="params">()</span></span>
</code></pre><h2 id="如何工作的">如何工作的</h2><p>我们通过看源码来看看scikit如何实现一个回归数据集，为定义的变量被假定成缺省值。令人惊喜的是这一过程实际上十分简单。<br>首先，一个特定大小的随机数组被创建：<br>     X = np.random.randn(n_samples, n_features)<br>     ground_truth = np.zeroes((np_samples, n_target))<br>     ground_truth[:n_informative, :] = 100*np.random.rand(n_informative，n_targets)<br>     y = np.dot(X, ground_truth) + bias<br>因为Numpy的广播特征，偏置值是一个数值，会被添加到每一个样例。最后在对每一样例添加噪音，我们就有回归的数值了。</p>
<h1 id="规整数据到标准格式">规整数据到标准格式</h1><p>处理过程最好将数据规整成为标准格式。标准格式可能是最重要的特征所有的数据。如果你接触过统计。那你就要考虑Z-评分。</p>
<h2 id="做好准备-1">做好准备</h2><p>规整数据这个过程十分重要，一系列机器学习算法，对于不同的规格表现的不同（甚至不正确）。例如：支持向量机如果数据没有规整则性能十分差，因为他优化的时候使用了一个距离函数，对于0-10到0-1。<br>我们首先需要引用preprocessing这个模块。</p>
<pre><code><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing
<span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># we'll need it later</span>
</code></pre><h2 id="怎样使用">怎样使用</h2><p>对于boston数据集，运行下面的命令行：</p>
<pre><code>X[:, :<span class="number">3</span>].mean(axis=<span class="number">0</span>) <span class="preprocessor">#mean of the first <span class="number">3</span> features</span>
<span class="built_in">array</span>([ <span class="number">3.59376071</span>, <span class="number">11.36363636</span>, <span class="number">11.13677866</span>])
X[:, :<span class="number">3</span>].<span class="built_in">std</span>(axis=<span class="number">0</span>)
<span class="built_in">array</span>([ <span class="number">8.58828355</span>, <span class="number">23.29939569</span>, <span class="number">6.85357058</span>])
</code></pre><p>这里实际上有很多初始化的过程，首先第一个特征有最小的平均值，但是变化超过了第三特征，这个第二特征，有最大的平均值和标准差，这有最广的值：</p>
<pre><code>X_2 = preprocessing.<span class="function"><span class="title">scale</span><span class="params">(X[:, :<span class="number">3</span>])</span></span>
X_2.<span class="function"><span class="title">mean</span><span class="params">(axis=<span class="number">0</span>)</span></span>
<span class="function"><span class="title">array</span><span class="params">([ <span class="number">6.34099712</span>e-<span class="number">17</span>, -<span class="number">6.34319123</span>e-<span class="number">16</span>, -<span class="number">2.68291099</span>e-<span class="number">15</span>])</span></span>
X_2.<span class="function"><span class="title">std</span><span class="params">(axis=<span class="number">0</span>)</span></span>
<span class="function"><span class="title">array</span><span class="params">([ <span class="number">1</span>., <span class="number">1</span>., <span class="number">1</span>.])</span></span>
</code></pre><h2 id="如何工作">如何工作</h2><p>中心规整的方法极其简单，就是<strong>减去平均值除以标准差</strong>。<br>另外这个函数可以很简单的被调用，尤其适用接下来的管道，对于独立的规整数据同样很实用。</p>
<pre><code>my_scaler = preprocessing.<span class="function"><span class="title">StandardScaler</span><span class="params">()</span></span>
my_scaler.<span class="function"><span class="title">fit</span><span class="params">(X[:, :<span class="number">3</span>])</span></span>
my_scaler.<span class="function"><span class="title">transform</span><span class="params">(X[:, :<span class="number">3</span>])</span></span>.<span class="function"><span class="title">mean</span><span class="params">(axis=<span class="number">0</span>)</span></span>
<span class="function"><span class="title">array</span><span class="params">([ <span class="number">6.34099712</span>e-<span class="number">17</span>, -<span class="number">6.34319123</span>e-<span class="number">16</span>, -<span class="number">2.68291099</span>e-<span class="number">15</span>])</span></span>
</code></pre><p>让特征的平均数是0，标准差是1，不是唯一的有用的规整方法。这里有MinMaxScaler类，规整数据到特定的范围：</p>
<pre><code>my_minmax_scaler = preprocessing.<span class="function"><span class="title">MinMaxScaler</span><span class="params">()</span></span>
my_minmax_scaler.<span class="function"><span class="title">fit</span><span class="params">(X[:, :<span class="number">3</span>])</span></span>
my_minmax_scaler.<span class="function"><span class="title">transform</span><span class="params">(X[:, :<span class="number">3</span>])</span></span>.<span class="function"><span class="title">max</span><span class="params">(axis=<span class="number">0</span>)</span></span>
<span class="function"><span class="title">array</span><span class="params">([ <span class="number">1</span>., <span class="number">1</span>., <span class="number">1</span>.])</span></span>
</code></pre><p>这里也十分容易的改变均值和标准差的缺省值。</p>
<pre><code>my_odd_scaler = preprocessing.<span class="function"><span class="title">MinMaxScaler</span><span class="params">(feature_range=(-<span class="number">3.14</span>,<span class="number">3.14</span>)</span></span>)
</code></pre><p>另外一种选择是，正则化。这会让每一个样例长度为1.这和之前的处理不一样，我们使用以下的命令：</p>
<pre><code>normalized_X = preprocessing.<span class="function"><span class="title">normalize</span><span class="params">(X[:, :<span class="number">3</span>])</span></span>
</code></pre><p>这并不是有明显的作用，对于三个点的欧几里德距离（1，1，0），（3，3，0），（1，-1，0）第一个和第三个向量距离比第一个和第二个之间的距离短，虽然1和3是正交的然而第一个和第二个点的，虽然距离不正则化的数据会误导。</p>
<h1 id="更多">更多</h1><p>这里可以使用StandardScaler规整平均值，例如我们可以简单地实现特定的转化。</p>
<pre><code>my_useless_scaler = preprocessing.<span class="function"><span class="title">StandardScaler</span><span class="params">(with_mean=False, with_std=False)</span></span>
transformed_sd = my_useless_scaler.<span class="function"><span class="title">fit_transform</span><span class="params">(X[:, :<span class="number">3</span>])</span></span>.<span class="function"><span class="title">std</span><span class="params">(axis=<span class="number">0</span>)</span></span>
original_sd = X[:, :<span class="number">3</span>].<span class="function"><span class="title">std</span><span class="params">(axis=<span class="number">0</span>)</span></span>
np.<span class="function"><span class="title">array_equal</span><span class="params">(transformed_sd, original_sd)</span></span>
</code></pre><h2 id="处理稀疏矩阵插值">处理稀疏矩阵插值</h2><p>稀疏矩阵不能被处理，当处理规整的时候。数据应该从0转化成非0值</p>
<pre><code>matrix =<span class="function"> scipy.sparse.eye(</span>1000<span class="function">)</span>
preprocessing.scale(matrix<span class="function">)</span>
ValueError: Cannot center<span class="instruction"> sparse </span>matrices: pass 'with_mean=False' instead
See docstring for motivation<span class="instruction"> and </span>alternatives.
</code></pre><p>另外一种选择是使用todense（）函数，不过他有潜在的内存错误风险。</p>
<h1 id="使用阀值创建二进制特征">使用阀值创建二进制特征</h1><p>上一节，我们把数据都转化成了正规的形式，现在我们来考虑另外一种转化。</p>
<h2 id="准备">准备</h2><p>创建二进制特征是一个非常有用的方法。但是使用的时候要特别的小心。我们使用boston数据集来创造二进制输出。<br>第一，载入数据集：</p>
<pre><code><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets
boston = datasets.load_boston()
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
</code></pre><h2 id="如何去做-1">如何去做</h2><p>与数据规整一样，我们也有两种方法：<br>    preprocessing.binarize #(a function)<br>    preprocessing.Binarizer #(a class)<br>这个数据集目标变量是房价，这个数据集是对回归的测试和做接下的预测，现在考虑如果我们只使用回归来预测。为了完成这个，我们设置平均值的阀值，如果大于阀值则为1，小于则为0.<br>    from sklearn import preprocessing<br>    new_target = preprocessing.binarize(boston.target,threshold=boston.target.mean())<br>    new_target[:5]<br>    array([ 1., 0., 1., 1., 1.])</p>
<p>然后我们检查，它的结果是否正确。<br>    (boston.target[:5] &gt; boston.target.mean()).astype(int)<br>    array([1, 0, 1, 1, 1])<br>如果我们使用内置的Binarizers类：<br>    bin = preprocessing.Binarizer(boston.target.mean())<br>    new_target = bin.fit_transform(boston.target)<br>    new_target[:5]<br>    array([ 1., 0., 1., 1., 1.])</p>
<h2 id="如何工作-1">如何工作</h2><p>这个太明显了，使用了条件语句判断是否这个值大于阀值，大于是1.</p>
<h2 id="更多-1">更多</h2><p>我们来使用fit方法来处理矩阵。</p>
<h2 id="处理目录变量">处理目录变量</h2><p>目录变量一方面可以提供大量有价值的信息，另一方面它很有可能是文本变量我们要把文本和intergers类型联系起来。<br>所以我们需要使用实数代替文本，但是我们实际上不能用id这个字段代表他们。因为我们要避免相同的问题在创建二元特征时。如果数据是连续的，这样一定会打断连续。</p>
<h1 id="准备-1">准备</h1><p>boston数据集在这里并不适用，这里我们使用iris数据集。<br>    from sklearn import datasets<br>    iris = datasets.load_iris()<br>    X = iris.data<br>    y = iris.target<br>接下来我们合并数据集成为一个数据集。<br>    import numpy as np<br>    d = np.column_stack((x,y))<br>    from sklearn import preprocessing<br>    text_encoder = preprocessing.OneHotEncoder()<br>    text_encoder.fit_transform(d[:, -1:]).toarray()[:5]</p>
<h2 id="如何工作-2">如何工作</h2><p>编码为每一个目录性变量创建了附加的特征，把值返回稀疏矩阵。这个结果在系数矩阵中被定义，每一行新特征是全0，除了与特征有关的那一列。因此很有意义使用稀疏矩阵存储数据。<br>text_encoder目前是一个标准的scikit模型，我们可以多次使用他。</p>
<pre><code>text_encoder.transform(np.ones((<span class="number">3</span>, <span class="number">1</span>))).toarray()
<span class="built_in">array</span>([[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],
[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],
[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]])
</code></pre><h2 id="更多-2">更多</h2><p>DictVectorizers是一个好的选择，如果让你的程序和scikit库的关联性减小。同时对于复杂的情况patsy是一个很好的选择。<br>    from sklearn.feature_extraction import DictVectorizer<br>    dv = DictVectorizer()<br>    my_dict = [{‘species’: iris.target_names[i]} for i in y]<br>    dv.fit_transform(my_dict).toarray()[:5]<br>    array([[ 1., 0., 0.],<br>    [ 1., 0., 0.],<br>    [ 1., 0., 0.],<br>    [ 1., 0., 0.],<br>    [ 1., 0., 0.]])<br>patsy是另一个包。经常用来连接StatsModels，patsy把字符串变成矩阵。<br>     import patsy<br>    patsy.dmatrix(“0 + C(species)”, {‘species’: iris.target})</p>
<h1 id="二进制标签特征">二进制标签特征</h1><p>在这一节，我们使用不同的思路看待目录变量。一般只有一个或两个标签比较重要，这时避免多余的维度是十分明智的。</p>
<h2 id="准备-2">准备</h2><p>这使我们使用LabelBinarizer代替OneHotencode。只是阈值和目录表量的结合。<br>    from sklearn import datasets as d<br>    iris = d.load_iris()<br>    target = iris.target</p>
<h2 id="这样去做">这样去做</h2><p>首先载入包。<br>    from sklearn.preprocessing import LabelBinarizer<br>    label_binarizer = LabelBinarizer()<br>接下来，转化目标输出到新的空间。<br>     new_target = label_binarizer.fit_transform(target)<br>我们看看发生了什么。</p>
<pre><code>&gt;&gt;&gt; new_target.shape
(<span class="number">150</span>, <span class="number">3</span>)
&gt;&gt;&gt; new_target[:<span class="number">5</span>]
<span class="built_in">array</span>([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],
[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],
[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],
[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],
[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]])
&gt;&gt;&gt; new_target[-<span class="number">5</span>:]
<span class="built_in">array</span>([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],
[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],
[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],
[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],
[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])
&gt;&gt;&gt; label_binarizer.<span class="function">classes_
<span class="title">array</span><span class="params">([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span></span>
</code></pre><h2 id="如何工作-3">如何工作</h2><pre><code>这个数据集有三组值，我们给出的值一定要存在标签中，否则就会报错。
</code></pre><h2 id="更多-3">更多</h2><pre><code>我们还可以指定，代表正数和代表负数的值。
label_binarizer = <span class="function"><span class="title">LabelBinarizer</span><span class="params">(neg_label=-<span class="number">1000</span>, pos_label=<span class="number">1000</span>)</span></span>
label_binarizer.<span class="function"><span class="title">fit_transform</span><span class="params">(target)</span></span>[:<span class="number">5</span>]
</code></pre><h1 id="计算缺失值的几种策略">计算缺失值的几种策略</h1><p>现实数据会有很多的缺失值，我们有很多的方法处理它。在这一节我们提供几种方法，看看哪种更符合你的情况。</p>
<h2 id="准备-3">准备</h2><p>我们首先制造缺失的值。<br>    from sklearn import datasets<br>    import numpy as np<br>    iris = datasets.load_iris()<br>    iris_X = iris.data<br>    masking_array = np.random.binomial(1, .25,<br>    iris_X.shape).astype(bool)<br>    iris_X[masking_array] = np.nan</p>
<h2 id="如何去做-2">如何去做</h2><pre><code>&gt;&gt;&gt; from sklearn import preprocessing
impute = preprocessing.Imputer()
iris_X_prime = impute.fit_transform(iris_X)
iris_X_prime[:<span class="number">5</span>]
<span class="built_in">array</span>([[ <span class="number">5.1</span> , <span class="number">3.5</span> , <span class="number">1.4</span> , <span class="number">0.2</span> ],
[ <span class="number">4.9</span> , <span class="number">3.</span> , <span class="number">1.4</span> , <span class="number">0.2</span> ],
[ <span class="number">4.7</span> , <span class="number">3.2</span> , <span class="number">1.3</span> , <span class="number">0.2</span> ],
[ <span class="number">5.87923077</span>, <span class="number">3.1</span> , <span class="number">1.5</span> , <span class="number">0.2</span> ],
[ <span class="number">5.</span> , <span class="number">3.6</span> , <span class="number">1.4</span> , <span class="number">0.2</span> ]])
</code></pre><h2 id="如何工作-4">如何工作</h2><p>计算依赖于不同的策略，缺省值是平均数，他们分别是：</p>
<ul>
<li>平均值</li>
<li>中位数</li>
<li>众数</li>
</ul>
<p>如果我们采用不同的策略只需要在前面指定，<br>     impute = preprocessing.Imputer(strategy=’median’)<br>我们之前的假设都是NAN为缺失的值，现在我们考虑如果缺失的值是-1.我们应该怎样做？<br>     impute = preprocessing.Imputer(missing_values=-1)<br>    iris_X_prime = impute.fit_transform(iris_X)<br>    iris_X_prime[:5]</p>
<h2 id="更多-4">更多</h2><p>其实pandas这个库，处理这个比较灵活也比较好：<br>    import pandas as pd<br>    iris_X[masking_array] = np.nan<br>    iris_df = pd.DataFrame(iris_X, columns=iris.feature_names)<br>    iris_df.fillna(iris_df.mean())[‘sepal length (cm)’].head(5)</p>
<h1 id="使用管道来多任务预处理">使用管道来多任务预处理</h1><p>管道这种工具被使用的十分频繁，它允许快速和更好的构建模型，适用于整个数据。而不是只能使用一步。</p>
<h2 id="准备-4">准备</h2><p>我们考虑这样一种任务，处理缺失的值，和让均值为0，标准差为1。<br>首先我们创造数据：<br>    from sklearn import datasets<br>    import numpy as np<br>    mat = datasets.make_spd_matrix(10)<br>    masking_array = np.random.binomial(1, .1, mat.shape).astype(bool)<br>    mat[masking_array] = np.nan<br>    mat[:4, :4]<br>    array([[ 0.56716186, -0.20344151, nan, -0.22579163],<br>    [ nan, 1.98881836, -2.25445983, 1.27024191],<br>    [ 0.29327486, -2.25445983, 3.15525425, -1.64685403],<br>    [-0.22579163, 1.27024191, -1.64685403, 1.32240835]])</p>
<h2 id="怎样去做-1">怎样去做</h2><p>如果不使用管道，那我们将这样处理;</p>
<pre><code>&gt;&gt;&gt; from sklearn import preprocessing
&gt;&gt;&gt; impute = preprocessing.Imputer()
&gt;&gt;&gt; scaler = preprocessing.StandardScaler()
&gt;&gt;&gt; mat_imputed = impute.fit_transform(mat)
&gt;&gt;&gt; mat_imputed[:<span class="number">4</span>, :<span class="number">4</span>]
<span class="built_in">array</span>([[ <span class="number">0.56716186</span>, -<span class="number">0.20344151</span>, -<span class="number">0.80554023</span>, -<span class="number">0.22579163</span>],
[ <span class="number">0.04235695</span>, <span class="number">1.98881836</span>, -<span class="number">2.25445983</span>, <span class="number">1.27024191</span>],
[ <span class="number">0.29327486</span>, -<span class="number">2.25445983</span>, <span class="number">3.15525425</span>, -<span class="number">1.64685403</span>],
[-<span class="number">0.22579163</span>, <span class="number">1.27024191</span>, -<span class="number">1.64685403</span>, <span class="number">1.32240835</span>]])
&gt;&gt;&gt; mat_imp_and_scaled = scaler.fit_transform(mat_imputed)
<span class="built_in">array</span>([[ <span class="number">2.235e+00</span>, -<span class="number">6.291e-01</span>, <span class="number">1.427e-16</span>, -<span class="number">7.496e-01</span>],
[ <span class="number">0.000e+00</span>, <span class="number">1.158e+00</span>, -<span class="number">9.309e-01</span>, <span class="number">9.072e-01</span>],
[ <span class="number">1.068e+00</span>, -<span class="number">2.301e+00</span>, <span class="number">2.545e+00</span>, -<span class="number">2.323e+00</span>],
[ -<span class="number">1.142e+00</span>, <span class="number">5.721e-01</span>, -<span class="number">5.405e-01</span>, <span class="number">9.650e-01</span>]])
</code></pre><p>注意之前的缺失的值是0，这是因为我们使用了平均数的策略，然后规整的时候又减了平均值。<br>那我们来看看使用管道的情况：<br>    from sklearn import pipeline<br>    pipe = pipeline.Pipeline([(‘impute’, impute), (‘scaler’, scaler)])<br>这时的pipe是：</p>
<pre><code>&gt;&gt;&gt; pipe
Pipeline<span class="list">(<span class="keyword">steps=</span>[<span class="list">(<span class="quoted">'impute</span>', Imputer<span class="list">(<span class="keyword">axis=0</span>, copy=True, missing_
values=<span class="quoted">'NaN</span>', strategy=<span class="quoted">'mean</span>', verbose=0)</span>)</span>, <span class="list">(<span class="quoted">'scalar</span>',
StandardScaler<span class="list">(<span class="keyword">copy=True</span>, with_mean=True, with_std=True)</span>)</span>])</span>
</code></pre><p>接下来使用fit_transform方法，这样就把分开的步骤合并成了一步。</p>
<pre><code>&gt;&gt;&gt; new_mat = pipe.fit_transform(mat)
&gt;&gt;&gt; new_mat [:<span class="number">4</span>, :<span class="number">4</span>]
<span class="built_in">array</span>([[ <span class="number">2.235e+00</span>, -<span class="number">6.291e-01</span>, <span class="number">1.427e-16</span>, -<span class="number">7.496e-01</span>],
[ <span class="number">0.000e+00</span>, <span class="number">1.158e+00</span>, -<span class="number">9.309e-01</span>, <span class="number">9.072e-01</span>],
[ <span class="number">1.068e+00</span>, -<span class="number">2.301e+00</span>, <span class="number">2.545e+00</span>, -<span class="number">2.323e+00</span>],
[ -<span class="number">1.142e+00</span>, <span class="number">5.721e-01</span>, -<span class="number">5.405e-01</span>, <span class="number">9.650e-01</span>]])
</code></pre><p>接下来我们就会看见这个理念是多麽的强大。这并不停止处理的脚步，同时也可以轻松的完成维度约简，对于不同的学习方法。我们会在PCA中看见。</p>
<h2 id="如何工作-5">如何工作</h2><p>正如刚刚提到的pipeline使用三种函数：</p>
<ul>
<li>fit</li>
<li>transform</li>
<li><p>fit_transform(常规方法)</p>
<pre><code><span class="keyword">*</span><span class="keyword">*</span>没看懂<span class="keyword">*</span><span class="keyword">*</span>
</code></pre><h1 id="使用PCA进行属性约简">使用PCA进行属性约简</h1><p>现在是使用高级的数学方法的时候了。这里我们使用PCA这个简单地统计方法。</p>
<h2 id="准备-5">准备</h2><p>PCA是scikit的库，在这一章我们还要介绍其他几个分解方法。<br>我们使用iris数据集，但是最好使用自己的数据。<br>  from sklearn import datasets<br>  iris = datasets.load_iris()<br>  iris_X = iris.data</p>
<h2 id="怎样去做-2">怎样去做</h2><p>首先，载入分解模块<br>   from sklearn import decomposition<br>我们生成PCA对象，<br>  pca = decomposition.PCA()<br>  pca<br>  PCA(copy=True, n_components=None, whiten=False)<br>比较其他对象，PCA使用很少的几个参数。现在PCA对象被创建。简单转化这个数据通过fit_transform方法。<br>   iris_pca = pca.fit_transform(iris_X)</p>
<h2 id="怎样工作-1">怎样工作</h2><p>PCA有一个通用的数学定义，和一个特定的情况下在数据分析。PCA使用正交向量代表原始数据矩阵。<br>一般来说，PCA把原始数据集映射到新的空间，他们的列向量都正交。在数据分析层面，PCA转化数据的协方差矩阵到列向量，解释每一列之间的相似度。例如。对于iris数据集92.5%就是数据的第一方面。<br>这个非常的有用，因为维度对于数据分析数据。对于高维度的数据，在算法的应用可能会出现<strong>过拟合</strong>，如果大多数潜在的数据的结构可以代表很少的维度，这个很值得讨论。<br>为了举例说明，我们使用PCA转化iris数据集，我们只包括两个维度。<br>  pca = decomposition.PCA(n_components=2)<br>  iris_X_prime = pca.fit_transform(iris_X)<br>  iris_X_prime.shape</p>
</li>
</ul>
<p>这两个维度，仍然包括大多数离散型。我们来看看两个能保留多少，<br>     pca.explained_variance<em>ratio</em>.sum()<br>     0.9776</p>
<h2 id="更多-5">更多</h2><p>PCA对象可以被创建。例如，如果我们想使用特定的比例。PCA应该这样创建：<br>    pca = decomposition.PCA(n_components=.98)<br>    iris_X_prime = pca.fit(iris_X)<br>    pca.explained_variance<em>ratio</em>.sum()</p>
<h1 id="使用因子分析用于约简">使用因子分析用于约简</h1><p>因子分析是另一个技术我们用于属性约简。然而，因子分析使用假设对于减少特征。<br>这个方法，将减少特征从我们的样例，理解变量的独立性。</p>
<h2 id="准备-6">准备</h2><p>为了比较PCA和因子分析，我们首先引入因子分析。<br>     from sklearn.decomposition import FactorAnalysis</p>
<h2 id="如何去做-3">如何去做</h2><p>从编码的层面，因子分析和PCA很相似。<br>    fa = FactorAnalysis(n_components=2)<br>    iris_two_dim = fa.fit_transform(iris.data)<br>因子分析是一个概率转化，我们可以检查不同的层面，例如log似然度。<br>因子分析也不是没有瑕疵。原因是你没有测试模型的输出，你测试模型作为准备的步骤，但是错误一定会在测试特定的模型。</p>
<h2 id="怎样工作-2">怎样工作</h2><p>因子分析和主成分分析相似，都会覆盖之前的。然而最重要的，PCA是一个线性转化，每一个子类都会正交。例如，你可以考虑PCA作为又M个维度减为N的方法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scikit/">scikit</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-PCA" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/13/PCA/" class="article-date">
  	<time datetime="2015-12-13T15:26:31.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/PCA/">PCA</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="主成分分析">主成分分析</h1><p><a href="http://dataunion.org/13702.html" target="_blank" rel="external">http://dataunion.org/13702.html</a></p>
<p>深度好文记录一下</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scikit/">scikit</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-windows下安装pip-和pip-upgraed配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/26/windows下安装pip-和pip-upgraed配置/" class="article-date">
  	<time datetime="2015-11-26T07:02:07.000Z" itemprop="datePublished">2015-11-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/26/windows下安装pip-和pip-upgraed配置/">windows下安装pip 和pip --upgraed配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="windows_下进行python开发">windows 下进行python开发</h1><p>说实话在Windows下开发python配置要比较麻烦，从一开始使用pip install开始我就遇见了不少麻烦，但是由于其他工具远比Linux下方便，自己也没钱买mac。还是有必要配置好开发环境的说。</p>
<h2 id="安装pip">安装pip</h2><p>这步没啥难度，直接照网上说的做没有任何问题，我就记录下已经出问题的地方。</p>
<p>#unable to find vcvarsall.bat#<br>这个问题比较经典，其实的原因是python和c的接口已经指定了平台为90，但是我们用的VS版本已经是110或者120了自然会有问题。然后谷歌出的方法是：</p>
<blockquote>
<p>Update: Comments below point out that the instructions here may be dangerous. Consider using the Visual C++ 2008 Express edition and NOT using the original answer below. Original error message means Visual C++ 2008 is not installed</p>
<p>Execute the following command based on the version of Visual Studio installed:</p>
<p>Visual Studio 2010 (VS10): SET VS90COMNTOOLS=%VS100COMNTOOLS%</p>
<p>Visual Studio 2012 (VS11): SET VS90COMNTOOLS=%VS110COMNTOOLS%</p>
<p>Visual Studio 2013 (VS12): SET VS90COMNTOOLS=%VS120COMNTOOLS%<br>但是在我的电脑上这种设置却没有作用，后来发现缺少vs支持python的插件，所以去微软官网下载。<a href="http://download.microsoft.com/download/7/9/6/796EF2E4-801B-4FC4-AB28-B59FBF6D907B/VCForPython27.msi" title="下载地址" target="_blank" rel="external">http://download.microsoft.com/download/7/9/6/796EF2E4-801B-4FC4-AB28-B59FBF6D907B/VCForPython27.msi</a><br>然后就ok了</p>
<p>#douban源#<br>最后说一下如何更换pip源，其实就是后面加上 pip install numpy -i <a href="http://pypi.douban.com/simple" target="_blank" rel="external">http://pypi.douban.com/simple</a> 话说豆瓣这么文艺的网站，在程序员眼中只是个源。<br><strong>总之，Windows开发python真的挺麻烦，真的需要个mac</strong></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pip/">pip</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-pandas-function-and-mapping" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/13/pandas-function-and-mapping/" class="article-date">
  	<time datetime="2015-11-13T15:50:27.000Z" itemprop="datePublished">2015-11-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/13/pandas-function-and-mapping/">pandas function and mapping</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-getting-to-Know-Your-Data" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/05/getting-to-Know-Your-Data/" class="article-date">
  	<time datetime="2015-11-05T14:18:22.000Z" itemprop="datePublished">2015-11-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/05/getting-to-Know-Your-Data/">getting to Know Your Data</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读data mining concept 3rd Editon，<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a  href="/2015/11/05/getting-to-Know-Your-Data/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-merge" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/28/merge/" class="article-date">
  	<time datetime="2015-10-28T15:15:57.000Z" itemprop="datePublished">2015-10-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/28/merge/">Time</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-xgboost" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/27/xgboost/" class="article-date">
  	<time datetime="2015-10-27T12:51:08.000Z" itemprop="datePublished">2015-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/27/xgboost/">xgboost window install</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>感觉如果再不会使用xgboost简直太土了，就算对于GBDT细节仍然存在疑问，但是还是强行学一波xgboost。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xgboost/">xgboost</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/27/xgboost/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数据管道的简单分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/26/数据管道的简单分析/" class="article-date">
  	<time datetime="2015-10-26T13:40:37.000Z" itemprop="datePublished">2015-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/26/数据管道的简单分析/">数据管道的简单分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里看见一篇外国人写的数据处理的入门，感觉很适合新手，就简单翻译一下，又加上了一点个人的理解。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data/">data</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/26/数据管道的简单分析/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-特征工程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/20/特征工程/" class="article-date">
  	<time datetime="2015-10-20T11:21:28.000Z" itemprop="datePublished">2015-10-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/20/特征工程/">特征工程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看过许多kaggle竞赛的论文，无一例外讲到了Feature engineering。今天来总结一下，使用pandas来进行 Feature engineering的几种方法，这里就使用我这一段看的kaggle-101的题。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ML/">ML</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/10/20/特征工程/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-scikit-learn-for-SGD" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/19/scikit-learn-for-SGD/" class="article-date">
  	<time datetime="2015-10-19T04:21:27.000Z" itemprop="datePublished">2015-10-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/19/scikit-learn-for-SGD/">scikit-learn for SGD</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SGD随机梯度下降在ML中十分高效。本文简要介绍一下它在scikit-learn的使用。原文地址：<a href="http://scikit-learn.org/stable/modules/sgd.html">http://scikit-learn.org/stable/modules/sgd.html</a><br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a  href="/2015/10/19/scikit-learn-for-SGD/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 刘思亮
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>